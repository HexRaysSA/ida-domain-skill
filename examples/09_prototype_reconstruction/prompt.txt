# Exercise 09: Reconstruct Function Prototypes from Callsites
Category: C. Function Boundary, Signature, Types, and ABI Reality Checks

## Binary
input.i64

## Binary Requirements
- Stripped binary with internal functions lacking type info
- Clear calling convention (x64 SysV or Windows x64)
- Functions with varied signatures:
  - Different argument counts (0-6+)
  - Mixed types (ints, pointers, structs by value)
  - Return value variations (void, int, pointer)
- Some functions called from multiple sites
- Usage patterns that reveal types:
  - Buffer passed to memcpy → likely pointer + size
  - Return value used in comparison → likely int/bool
  - Argument passed to strlen → likely string pointer

## Task
Select a set of "unknown" internal functions. For each, infer argument count and types from:
1. Calling convention rules (register/stack usage)
2. Stack cleanup patterns (if applicable)
3. Register usage at call sites
4. Operand sizes in caller setup
5. Usage patterns:
   - Pointer passed to memcpy → buffer
   - Value compared to 0 → int/bool return
   - Dereferenced → pointer type

Apply tinfo_t prototypes and re-run decompilation.

## Expected Output
- Inferred prototypes for target functions
- Confidence scores based on evidence count
- Applied type info in IDA
- Before/after decompilation comparison

## Expected Class of Solution
- Callsite enumeration and argument tracking
- Calling convention awareness (x64 ABI specifics)
- Type inference heuristics from usage patterns
- IDA tinfo_t API usage for type application
- Validation via decompiler output improvement

## Evaluation Criteria
- Argument count accuracy
- Type inference quality
- Decompiler output improvement
- Handling of edge cases (varargs, tail calls)
