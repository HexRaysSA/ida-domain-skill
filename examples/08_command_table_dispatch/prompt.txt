# Exercise 08: Detect and Annotate Command Tables / Opcode Dispatch
Category: B. Strings, Dataflow-ish Heuristics, and Configuration Recovery

## Binary
input.i64

## Binary Requirements
- Binary with switch/jump-table based dispatch:
  - Command/opcode dispatcher (network protocol, VM, plugin system)
  - Jump table in .rodata or computed
  - At least 8-15 distinct handlers
- Handler functions should have:
  - Identifiable patterns (string refs, specific API calls)
  - Varying complexity (some simple, some complex)
- May include:
  - Sparse switch (gaps in opcode range)
  - Nested dispatch (sub-commands)
  - Bounds checking before dispatch

## Task
Automatically detect switch/jump-table dispatchers and build an opcode table:
1. Locate dispatch points (switch statements, indirect jumps via table)
2. Extract the jump table entries
3. Map: opcode -> handler EA
4. For each handler, infer:
   - Handler signature (args, return type)
   - Key strings/constants used
   - Semantic hint from patterns
5. Rename handlers: `cmd_<opcode>_<hint>`

## Expected Output
- Dispatch table report:
  - Dispatcher function EA
  - Opcode range (min, max, sparse entries)
  - Handler mappings with metadata
- Renamed handler functions in IDA
- Optional: generated enum for opcodes

## Expected Class of Solution
- Switch/jump table detection via:
  - IDA's switch info APIs
  - Pattern matching for indirect jump + table
- Table extraction and bounds detection
- Handler analysis for hints:
  - String references
  - API calls
  - Constant patterns
- Consistent naming scheme application

## Evaluation Criteria
- Correct dispatch point identification
- Complete handler enumeration
- Quality of handler hints/names
- Handling of sparse and nested switches
