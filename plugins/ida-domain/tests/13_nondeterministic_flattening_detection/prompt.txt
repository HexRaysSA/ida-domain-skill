# Exercise 13: Flattening Detector + Basic "Unflatten" Annotations
Category: D. Control-Flow Obfuscation and Normalization

## Binary
input.i64

## Binary Requirements
- Binary obfuscated with control-flow flattening:
  - Tigress, OLLVM, or similar obfuscator
  - Dispatcher loop pattern (while/switch)
  - State variable controlling flow
  - All original blocks as switch cases
- Characteristics:
  - Single entry dispatcher block
  - State variable updated in each case
  - Original control flow hidden in state transitions
- At least 2-3 flattened functions of varying complexity

## Task
Detect control-flow flattening patterns and annotate for analysis:

1. Identify dispatcher pattern:
   - Loop with switch/indirect branch
   - State variable identification
   - Case block enumeration

2. Extract case targets:
   - Map state values to block addresses
   - Identify state transition logic
   - Reconstruct original flow order (where possible)

3. Generate annotations:
   - Comment blocks with state values
   - Label blocks with logical sequence hints
   - Generate ordered pseudo-CFG map

4. Bonus: Export to Graphviz with:
   - Original (flattened) CFG
   - Reconstructed logical flow overlay

## Expected Output
- Dispatcher identification report
- State variable location and type
- State-to-block mapping
- Annotated IDA database
- Optional: Graphviz CFG export

## Expected Class of Solution
- Pattern matching for dispatcher loop
- State variable tracking via:
  - Decompiler output analysis
  - Or direct dataflow on assignment patterns
- Block enumeration from switch/jump table
- State transition graph construction
- IDA comment/label APIs

## Evaluation Criteria
- Correct dispatcher identification
- Complete state-to-block mapping
- Quality of reconstructed flow hints
- Annotation usefulness for manual analysis
