# Exercise 17: Hook Surface Identification for Dynamic Instrumentation
Category: E. Patch Planning & Analysis Workflow Automation

## Binary
input.i64

## Binary Requirements
- Binary suitable for dynamic instrumentation:
  - Clear initialization sequence
  - Network communication (send/recv or equivalent)
  - Crypto operations
  - File I/O operations
  - Stable internal APIs (not inline-heavy)
- Mix of:
  - Exported functions (easy hooks)
  - Internal functions worth hooking
  - Wrapper functions around system APIs
- No heavy obfuscation (or pre-deobfuscated)

## Task
Given the binary, identify "good hook points" for Frida/DynamoRIO:

1. Categorize hook candidates:
   - **Exports**: Stable, easy to hook by name
   - **Init boundary**: Functions called after init but before behavior
   - **Network boundary**: Send/recv wrappers
   - **Crypto boundary**: Encrypt/decrypt entry points
   - **File boundary**: Read/write wrappers
   - **Central dispatchers**: High-value internal functions

2. For each candidate, provide:
   - Function EA and name (if any)
   - Calling convention
   - Argument guess (count, types)
   - Why this is a good hook point
   - Suggested instrumentation (log args, modify return, etc.)

3. Rank by usefulness for common RE tasks

## Expected Output
- Hook surface report:
  - Category (network, crypto, file, dispatch, etc.)
  - Function list with metadata
  - Frida snippet templates (optional)
- Priority ranking for analysis efficiency

## Expected Class of Solution
- Export enumeration
- API wrapper detection (thin functions calling imports)
- Callgraph position analysis (boundary functions)
- Calling convention inference
- Argument analysis from callsites

## Evaluation Criteria
- Coverage of major hook categories
- Quality of calling convention / argument guesses
- Practical usefulness of suggestions
- Ranking logic soundness
